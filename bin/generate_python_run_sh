#!/usr/bin/env python3

import os
import sys
import subprocess
import argparse

# Function to create virtual environment
def create_venv(venv_path):
    if not os.path.exists(venv_path):
        print(f"Creating virtual environment at {venv_path}...")
        subprocess.run([sys.executable, "-m", "venv", venv_path], check=True)
    else:
        print(f"Virtual environment already exists at {venv_path}.")

# Function to install dependencies from requirements.txt
def install_dependencies(venv_python, requirements_file):
    if os.path.exists(requirements_file):
        print(f"Installing dependencies from {requirements_file}...")
        subprocess.run([venv_python, "-m", "pip", "install", "-r", requirements_file], check=True)
    else:
        print(f"No {requirements_file} found. Skipping dependencies installation.")

# Function to generate run.sh script
def generate_run_script(script_path, script_name, run_script_name, venv_path, output_dir):
    run_script_content = f"""#!/bin/bash

# 获取当前脚本所在目录
script_path={script_path}

# 虚拟环境中的 Python 解释器路径
venv_python="$script_path/{venv_path}/bin/python"

# 检查虚拟环境是否存在
if [ -x "$venv_python" ]; then
    # 使用 exec 替换当前进程为虚拟环境中的 Python 解释器，传递所有参数
    exec "$venv_python" ${{script_path}}/{script_name} "$@"
else
    exec python3 ${{script_path}}/{script_name} "$@"
    exit 1
fi
"""
    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)

    run_script_path = os.path.join(output_dir, run_script_name)
    with open(run_script_path, "w") as run_script_file:
        run_script_file.write(run_script_content)

    # Make run.sh executable
    os.chmod(run_script_path, 0o755)
    print(f"run.sh script generated at {run_script_path}")
    
def replace_home_with_tilde(path):
    home_dir = os.path.expanduser("~")
    if path.startswith(home_dir):
        return path.replace(home_dir, "~", 1)
    return path

def main():
    parser = argparse.ArgumentParser(description="Generate run.sh script for a Python project.")
    parser.add_argument("python_script", help="The Python script that will be run by the generated run.sh.")
    parser.add_argument("-c", "--create-venv", action="store_true", help="Automatically create a virtual environment.")
    parser.add_argument("-i", "--install-deps", action="store_true", help="Automatically install dependencies from requirements.txt if it exists.")
    parser.add_argument("-v", "--venv-dir", default=".env", help="Directory name for the virtual environment (default: 'venv').")
    parser.add_argument("-o", "--output-dir", default=os.path.expanduser("~/.dotfiles/bin"), help="Directory to place the generated run.sh script (default: '~/.dotfiles/bin').")
    
    args = parser.parse_args()

    python_script = args.python_script
    if not os.path.exists(python_script):
        print(f"Error: Python script '{python_script}' does not exist.")
        sys.exit(1)

    # Get base name of Python script to name the run.sh
    script_name = os.path.basename(python_script)
    run_script_name = f"{os.path.splitext(script_name)[0]}"

    # Determine paths
    script_dir = os.path.dirname(python_script)
    venv_path = os.path.join(script_dir, args.venv_dir)
    requirements_file = os.path.join(script_dir, "requirements.txt")
    output_dir = args.output_dir

    # Create virtual environment if specified
    if args.create_venv:
        create_venv(venv_path)

    # Install dependencies if specified
    if args.install_deps:
        venv_python = os.path.join(venv_path, "bin", "python")
        if not os.path.exists(venv_python):
            print(f"Error: Virtual environment not found at {venv_path}. Cannot install dependencies.")
            sys.exit(1)
        install_dependencies(venv_python, requirements_file)

    # Generate run.sh script
    generate_run_script(replace_home_with_tilde(os.getcwd()), python_script, run_script_name, args.venv_dir, output_dir)

if __name__ == "__main__":
    main()
